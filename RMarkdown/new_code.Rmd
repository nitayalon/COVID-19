---
title: "Testing"
author: "Nitay Alon"
date: "May 5, 2020"
output: html_document
---

```{r load environemt}
library(beepr)
library(dplyr)
library(tidyverse)
```

```{r}
covid_data <- 
full_data_for_export %>% 
  select(-var) %>% 
  as.matrix()
n = nrow(covid_data)
X = covid_data[,1]
V = covid_data[,2]
W = covid_data[,3]
VW = V+W
Y = X - VW
ind <- 56
X_trimmed = X[ind:n]
V_trimmed = V[ind:n]
W_trimmed = W[ind:n]
VW_trimmed = V_trimmed+W_trimmed
Y_trimmed = X_trimmed - VW_trimmed
# input: X, V, W, 
# VW = V + W
# Y = X - VW
# n = lnength(X)
```

```{r validation plots}
plot(X / 1e5, type = 'l', col = 'blue')
lines(Y/ 1e5, col = 'red')
lines(VW/ 1e5, col = 'green')

plot(X_trimmed / 1e5, type = 'l', col = 'blue', ylim = c(0,2.5))
lines(Y_trimmed / 1e5, col = 'red')
lines(VW_trimmed / 1e5, col = 'green')
```


```{r comute the middle point for each data point}
n <- length(X_trimmed)
Y_middle=(Y_trimmed[1:(n-1)]+Y_trimmed[2:n])/2
Y_middle=c(Y_middle, Y_trimmed[n])
X_middle=(X_trimmed[1:(n-1)]+X_trimmed[2:n])/2
X_middle=c(X_middle, X_trimmed[n])
```

```{r validation plot}
plot(Y_middle, type = 'l', col = 'blue')
lines(Y_trimmed, col = 'red')

plot(X_middle, type = 'l', col = 'blue')
lines(X_trimmed, col = 'red')
```


```{r devide the day into binns}
partition_parameter = 100
del = 1/partition_parameter # dt
# Set the first 100 obs to same value - can be 52,53
x = y = vw = c()
x[1:partition_parameter]=X_trimmed[1]
y[1:partition_parameter]=Y_trimmed[1]
vw[1:partition_parameter]=VW_trimmed[1]
asympt = c()
LOGL = VAR1 = OBJ = OBJB = c()
T_final = T1 = matrix(0, ncol = 2, nrow = n)
```

1. Keep $\alpha = 1$
2. K = pop
3. Best random time

A. Repeat but with hhh finds the MLE
B. Set hhh by min-log-like
C. Find the optimal value of K
D. $alpha = 0.5$

Repeat for US as well
```{r random time estimation}
# NNN=1000 #What is the grid of K
#' One possibily is to take the maximal value of X, K = 1.25 * X_max
NNN=floor(max(X) / 100) #What is the grid of K
hhh_upper_limit = 200
number_of_inner_loops = 100
calibration_loops = 200
alpha = 0.5
cpp <- FALSE
gamma_hat = beta_hat = matrix(nrow = calibration_loops, ncol = hhh_upper_limit)
for(hhh in 1:hhh_upper_limit)
  {
    K = max(X) + hhh * NNN
    asympt[hhh] = K
    beta <- (X_trimmed[n]-X_trimmed[1])/ sum(max(1,Y_middle ^ alpha - Y_middle[1] ^ alpha)*(1 - (X_middle-X_middle[1]) / K))
    gamma <- (VW[n]-VW[1])/sum(max(1,Y_middle-Y_middle[1]))
    
    # beta_hat = c(beta_hat,beta)
    # gamma_hat = c(beta_hat,gamma)
    for(j in 1:calibration_loops)
    {
        res <- innerLoop(n,number_of_inner_loops,Beta = beta,Gamma = gamma,
                         Del = del,Alpha = alpha,
                         K = K,x = X_trimmed[1], vw = VW_trimmed[1], y = Y_trimmed[1])

        x = round(res[1,],5)
        vw = round(res[2,],5)
        y = round(res[3,],5)
      # # }
      # # else{
        # for(i in (number_of_inner_loops + 1):(number_of_inner_loops * 5 * n))
        # {
        #   # infection rate growth
        #   x[i] = x[i-1] + beta * y[i-1] ^ alpha * max(0, 1 - x[i-1] / K) * del
        #   # removed rate
        #   vw[i]=vw[i-1] + gamma * y[i-1] * del
        #   # Current ills
        #   y[i]=max(0,x[i]-vw[i])
        # }
      for(i in 1:n)
      {
        # random time transformation
        # The events where the pde solution equals to the emphirical values
        T1[i,1] = sum(x<=X_trimmed[i])
        T1[i,2] = sum(vw<=VW_trimmed[i])
      }
      T1=T1*del
      beta = beta * T1[n,1]/n
      gamma = gamma * T1[n,2]/n
      beta_hat[j,hhh] = beta
      gamma_hat[j,hhh] = gamma
    }
  T_final=T1
  TT=diff(T_final)-1
  print(colMeans(TT))
  COV=t(TT)%*%TT/(n-1)
  # The solution deviratives - Jacobi matrix
  AD=beta * Y_middle ^ alpha *max(0, 1 - X_middle / K)
  BD=gamma * Y_middle
  
  OBJ1=sum(log(AD)+log(BD)) #single figure - denom
  OBJ[hhh]=OBJ1+(n/2)*log(det(COV)) # likelihood when we use to BM's
  LOGL[hhh]=log(det(COV))
  VAR1[hhh]=mean(diag(COV))
  OBJB[hhh]=sum(log(AD))+(n/2)*log(COV[1,1]) # BM for single component for X only
}
print(COV)
# TT_cpp <- TT
# COV_cpp=t(TT)%*%TT/(n-1)
beep('sword')
# take the 5 points centered at K_max - repartiton the interval and compute a finer loop
```


```{r llk minimization}
plot(OBJB, type = 'l')
plot(OBJ, type = 'l')
```


Next we minimize OBJ and OBJB to find the optimal value of hhh
When we compute the CI we should consider the dimension of the data (Chi2)
```{r minimizing OBJ and OBJB}
uuB=min(OBJB)
vvB=which.min(OBJB)
beta_mle=beta_hat[nrow(beta_hat),vvB]
gamma_mle=gamma_hat[nrow(gamma_hat),vvB]
K=asympt[vvB]

uuA=min(OBJ)
vvA=which.min(OBJ)
beta_mle_A=beta_hat[nrow(beta_hat),vvA]
gamma_mle_A=gamma_hat[nrow(gamma_hat),vvA]
KA=asympt[vvA]

matrA = matrix(c(rep(1,11), t((vvA-5):(vvA+5)), t((vvA-5):(vvA+5))^2), nrow = 11);
cofsA = matrA / OBJ[(vvA-5):(vvA+5)]
wwA=-cofsA[2]/(2*cofsA[3])
FISHERA=2*cofsA[3]/NNN^2
KA=max(X)+wwA*NNN

matrB=matrix(c(rep(1,11), t((vvB-5):(vvB+5)), t((vvB-5):(vvB+5))^2), nrow = 11);
cofsB=matrB / OBJB[(vvB-5):(vvB+5)]
wwB=-cofsB[2]/(2*cofsB[3])
FISHERB=2*cofsB[3]/NNN^2
KB=max(X)+wwB*NNN
# Here we have to decide id we only compute for X or ofr (X,VW)
# if we keep past iteration - this is redundent

# beta = 1.227*10^-4
# gamma = 2.58187*10^-2
res_mle <- innerLoop(n,number_of_inner_loops,
                     Beta = beta_mle,
                     Gamma = gamma_mle,
                         Del = del,Alpha = alpha,
                         K = KA,x = X_trimmed[1], vw = VW_trimmed[1], y = Y_trimmed[1])

x_mle = round(res_mle[1,],5)
vw_mle = round(res_mle[2,],5)
y_ml = round(res_mle[3,],5)
for(i in 1:n)
{
    T1[i,1]=sum(x<=X[i])
    T1[i,2]=sum(vw<=VW[i])
}
T1=T1*del
TT=diff(T1)-1
COV=t(TT)%*%TT/(n-1)
AD=beta*Y_middle*max(K-X_middle,0)
BD=gamma*Y_middle
print(c(beta, gamma , beta/gamma))
```
beta should be $1.227*10^-4$  and gamma should be $2.58187*10^-2$

```{r validation plots}
plot(x[(1:length(x)) %% 100 == 0]/ 1e5, type = 'l', col = 'blue')
lines(X_trimmed/ 1e5, col = 'red')

plot(vw[(1:length(vw)) %% 100 == 0]/ 1e5, col = 'red', type = 'l')
lines(VW_trimmed / 1e5,col = 'blue')

plot(y[(1:length(y)) %% 100 == 0] / 1e5, col = 'red', type= 'l')
lines(Y_trimmed / 1e5, col = 'blue')
```

```{r model plots}
plot(log(x[(1:length(x)) %% 100 == 0]), type = 'l', col = 'blue', ylab = 'Log cases', xlab = 'Time')
lines(log(y[(1:length(x)) %% 100 == 0]), col = 'red')
lines(log(vw[(1:length(x)) %% 100 == 0]), col = 'green')
```

 Take the argmin and search for the first value where the llk increase by 10 (two-sided)

The entire code is wrapped in an external loop to test the starting day - decided by var1
Search for min(var1) * 1.5 and find, before the argmin 
Run only on days starting with x > 100 

Report $\gamma$, $\beta$, $K$, for each day and see that the starting day make no difference
$\beta ^ \frac{2}{3}$
