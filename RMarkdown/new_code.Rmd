---
title: "Testing"
author: "Nitay Alon"
date: "May 5, 2020"
output: html_document
---

```{r load environemt}
library(beepr)
library(dplyr)
library(tidyverse)
library(Rcpp)
```

```{r}
covid_data <- 
full_data_for_export %>% 
  select(-var) %>% 
  as.matrix()
ind <- 51
X = covid_data[ind:nrow(covid_data),1]
V = covid_data[ind:nrow(covid_data),2]
W = covid_data[ind:nrow(covid_data),3]
VW = V+W
Y = X - VW
n <- length(X)
# input: X, V, W, 
# VW = V + W
# Y = X - VW
# n = lnength(X)
```

```{r validation plots}
plot(X / 1e5, type = 'l', col = 'blue', ylim = c(0,2.5), panel.first = grid())
lines(Y/ 1e5, col = 'red')
lines(VW/ 1e5, col = 'green')
```

```{r comute the middle point for each data point}
n <- length(X)
Y_middle=(Y[1:(n-1)]+Y[2:n])/2
Y_middle=c(Y_middle, Y[n])
X_middle=(X[1:(n-1)]+X[2:n])/2
X_middle=c(X_middle, X[n])
```

```{r validation plot}
plot(Y_middle / 1e5, type = 'l', col = 'blue')
lines(Y / 1e5 , col = 'red')

plot(X_middle / 1e5 , type = 'l', col = 'blue')
lines(X / 1e5 , col = 'red')
```

```{r devide the day into binns}
partition_parameter = 100
del = 1/partition_parameter # dt
# Set the first 100 obs to same value - can be 52,53
asympt = c()
LOGL = VAR1 = OBJ = OBJB = c()
T_final = T1 = matrix(0, ncol = 2, nrow = n)
calibration_loops = 15
hhh_upper_limit = 400
gamma_hat = beta_hat = matrix(nrow = calibration_loops, ncol = hhh_upper_limit)
NNN = floor(max(X) / 100) #What is the grid of K
alpha = 0.5
```

1. Keep $\alpha = 1$
2. K = pop
3. Best random time

A. Repeat but with hhh finds the MLE
B. Set hhh by min-log-like
C. Find the optimal value of K
D. $alpha = 0.5$

Repeat for US as well
```{r random time estimation}
# This can be moved to lapply/sapply
for(hhh in 1:hhh_upper_limit)
  {
    K = max(X) + hhh * NNN
    asympt[hhh] = K
    beta <- (X[n]-X[1]) / sum(pmax(1,Y_middle ^ alpha - Y_middle[1] ^ alpha)*(1 - (X_middle-X_middle[1]) / K))
    gamma <- (VW[n]-VW[1]) / sum(pmax(1,Y_middle-Y_middle[1]))
    for(j in 1:calibration_loops)
    {
      res <- innerLoop(n, partition_parameter, Beta = beta,Gamma = gamma,
                         Del = del,Alpha = alpha,
                         K = K,x = X[1], vw = VW[1], y = Y[1])
  
        x = round(res[1,],7)
        vw = round(res[2,],7)
        y = round(res[3,],7)
        # random time transformation
        # The events where the pde solution equals to the emphirical values
      for(i in 1:n)
      {
        T1[i,1] = sum(x<=X[i])
        T1[i,2] = sum(vw<=VW[i])
      }
      T1=T1*del
      beta = beta * T1[n,1]/n
      gamma = gamma * T1[n,2]/n
      beta_hat[j,hhh] = beta
      gamma_hat[j,hhh] = gamma
    }
  res <- innerLoop(n, partition_parameter,Beta = beta,Gamma = gamma,
                   Del = del,Alpha = alpha,
                   K = K,x = X[1], vw = VW[1], y = Y[1])
  
  x = round(res[1,],7)
  vw = round(res[2,],7)
  y = round(res[3,],7)
  for(i in 1:n)
  {
    T1[i,1] = sum(x<=X[i])
    T1[i,2] = sum(vw<=VW[i])
  }
  T_final=T1*del
  TT=diff(T_final)-1
  print(colMeans(TT))
  COV=t(TT)%*%TT/(n-1)
  # The solution deviratives - Jacobi matrix
  AD = beta * Y_middle ^ alpha * pmax(0, 1 - X_middle / K)
  BD = gamma * Y_middle
  
  OBJ1=sum(log(AD)+log(BD)) #single figure - denom
  OBJ[hhh]=OBJ1+(n/2)*log(det(COV)) # likelihood when we use to BM's
  LOGL[hhh]=log(det(COV))
  VAR1[hhh]=mean(diag(COV))
  OBJB[hhh]=sum(log(AD))+(n/2)*log(COV[1,1]) # BM for single component for X only
}
beep('sword')
```

```{r llk minimization}
plot(1:hhh, OBJ, type = 'l', col = 'blue', ylim = c(200,800))
lines(1:hhh, OBJB, type = 'l' , col = 'red')
```


Next we minimize OBJ and OBJB to find the optimal value of hhh
When we compute the CI we should consider the dimension of the data (Chi2)
```{r minimizing OBJ and OBJB}
single_dim_llk=min(OBJB)
single_dim_llk_ind=which.min(OBJB)
beta_mle=beta_hat[nrow(beta_hat),single_dim_llk_ind]
gamma_mle=gamma_hat[nrow(gamma_hat),single_dim_llk_ind]
K_one_dim=asympt[single_dim_llk_ind]

two_dim_llk=min(OBJ)
two_dim_llk_ind=which.min(OBJ)
beta_mle_two_dim=beta_hat[nrow(beta_hat),two_dim_llk_ind]
gamma_mle_two_dim=gamma_hat[nrow(gamma_hat),two_dim_llk_ind]
K_two_dim=asympt[two_dim_llk_ind]

if(min(single_dim_llk_ind,two_dim_llk_ind)>5){
  matrA = matrix(c(t((two_dim_llk_ind-5):(two_dim_llk_ind+5)), t((two_dim_llk_ind-5):(two_dim_llk_ind+5))^2), nrow = 11);
  coefsA = (lm(formula = OBJ[(two_dim_llk_ind-5):(two_dim_llk_ind+5)] ~ matrA))$coef
  wwA = -coefsA[2]/(2*coefsA[3]) # minimum location - pm 1 from single_dim_llk_ind
  FISHERA = (2 * coefsA[3]) / (NNN^2)
  KA = max(X) + wwA*NNN
  print(c(KA - 2/sqrt(FISHERA), KA + 2/sqrt(FISHERA)))
  
  matrB=matrix(c(t((single_dim_llk_ind-5):(single_dim_llk_ind+5)), t((single_dim_llk_ind-5):(single_dim_llk_ind+5))^2), nrow = 11);
  cofsB = (lm(formula = OBJB[(single_dim_llk_ind-5):(single_dim_llk_ind+5)] ~ matrB))$coef
  wwB = -cofsB[2]/(2*cofsB[3])
  FISHERB=2*cofsB[3] / NNN^2
  KB=max(X)+wwB*NNN
  print(c(KB - 2/sqrt(FISHERB), KB + 2/sqrt(FISHERB)))
}
res_mle <- innerLoop(n,
                     partition_parameter,
                     Beta = beta_mle,
                     Gamma = gamma_mle,
                     Del = del,Alpha = alpha,
                     K = K_one_dim,
                     x = X[1], vw = VW[1], y = Y[1])

x_mle = round(res_mle[1,],7)
vw_mle = round(res_mle[2,],7)
y_mle = round(res_mle[3,],7)
for(i in 1:n)
{
    T1[i,1]=sum(x_mle<=X[i])
    T1[i,2]=sum(vw_mle<=VW[i])
}
T1=T1*del
TT=diff(T1)-1
colMeans(TT)
COV=t(TT)%*%TT/(n-1)
AD = beta * Y_middle ^ alpha * pmax(0, 1 - X_middle / K)
BD = gamma * Y_middle
print(c(beta_mle, gamma_mle * 100))
print(c(beta_mle_two_dim, gamma_mle_two_dim * 100))
print(c(K_one_dim, K_two_dim))
```
beta should be $1.227*10^-4$  and gamma should be $2.58187*10^-2$

```{r validation plots}
plot(X/ 1e5, col = 'blue' , type = 'b', pch=7, ylim = c(0,2.5), panel.first = grid())
lines(VW / 1e5,col = 'blue', type = 'b', pch=13)
lines(Y / 1e5, col = 'blue', type = 'b', pch=19)

lines(x_mle[(1:length(x_mle)) %% 100 == 0] / 1e5, col = 'red', type = 'b', pch=7)
lines(vw_mle[(1:length(vw_mle)) %% 100 == 0]/ 1e5, col = 'red', type = 'b', pch=13)
lines(y_mle[(1:length(y_mle)) %% 100 == 0] / 1e5, col = 'red', type = 'b', pch=19)
```

```{r model plots}
plot(log(x[(1:length(x)) %% 100 == 0]), type = 'l', col = 'blue', ylab = 'Log cases', xlab = 'Time')
lines(log(y[(1:length(x)) %% 100 == 0]), col = 'red')
lines(log(vw[(1:length(x)) %% 100 == 0]), col = 'green')
```

```{r validation plots}
plot(x[(1:length(x)) %% 100 == 0]/ 1e5, type = 'l', col = 'blue')
lines(X/ 1e5, col = 'red')

plot(vw[(1:length(vw)) %% 100 == 0]/ 1e5, col = 'blue', type = 'l')
lines(VW / 1e5,col = 'red')

plot(y[(1:length(y)) %% 100 == 0] / 1e5, col = 'blue', type= 'l')
lines(Y / 1e5, col = 'red', type='l')
```

 Take the argmin and search for the first value where the llk increase by 10 (two-sided)

The entire code is wrapped in an external loop to test the starting day - decided by var1
Search for min(var1) * 1.5 and find, before the argmin 
Run only on days starting with x > 100 

Report $\gamma$, $\beta$, $K$, for each day and see that the starting day make no difference
$\beta ^ \frac{2}{3}$
